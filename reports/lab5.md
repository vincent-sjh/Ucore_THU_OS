# lab5

宋建昊 2022010853

## 功能实现

- 定义并初始化两种死锁检测（mutex以及semaphore）使能以及其所需要的三个矩阵（available/allocation/request），完善其维护部分。

- 实现sys_enable_deadlock_detect的系统调用以进行使能设置，加入syscall函数的case中。

- 实现参数为三个矩阵的死锁检测函数，以供检测的时候进行调用。

  ```c
  int deadlock_detect(const int available[LOCK_POOL_SIZE],
  	const int allocation[NTHREAD][LOCK_POOL_SIZE],
  	const int request[NTHREAD][LOCK_POOL_SIZE]);
  ```

- 在mutex和semaphore的create和lock/unlock/up/down系统调用中加入死锁检测和维护参数矩阵的功能。

## 问答题

1. 在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。
   - 需要回收的资源有哪些？当主线程退出时，整个进程结束，需要回收的资源包括每个线程的栈空间，因为这些栈存储了线程的局部变量和调用信息，通常由线程库或自定义分配器提供；此外，线程控制块（struct thread）也需要回收，它包含线程的状态和调度信息，通常是动态分配的内存；线程可能持有的堆内存、文件描述符、同步原语（如互斥锁和信号量）以及线程局部存储（TLS）都需要清理，以防止资源泄漏；最后，进程的地址空间和进程控制块会在操作系统层面自动回收，但自定义实现可能需要显式释放某些资源以确保干净退出。
   - 其他线程的 `struct thread` 可能在哪些位置被引用，分别是否需要回收，为什么？其他线程的 struct thread 可能被引用在全局线程表中，例如一个数组或链表，用于管理所有线程，这种情况下需要回收，因为主线程退出意味着进程结束，这些结构不再需要，释放它们可以避免内存泄漏并确保系统资源干净。它们还可能出现在调度器的就绪队列或等待队列中，用于跟踪线程状态，这里也需要回收，因为线程终止后若不移除并释放，会导致调度器错误地尝试调度已无效的线程。在其他线程的局部变量或参数中也可能有引用，这种情况不需要直接回收引用本身，因为这些引用所在的栈会在进程退出时由操作系统自动清理，但需确保引用的 struct thread 内存被释放。如果创建线程的父线程保存了子线程的 struct thread 指针，例如用于跟踪子线程状态，这种引用也不需要单独回收，因为父线程的栈会随进程退出而释放，但目标 struct thread 仍需释放以避免泄漏。
2. 对比以下两种 `mutex_unlock` 中阻塞锁的实现，二者有什么区别？这些区别可能会导致什么问题？ （假设无论哪种实现，对应的 `mutex_lock` 均正确处理了 `m->locked`）

```
 1void mutex_unlock_v1(struct mutex *m)
 2{
 3   if (m->blocking) {
 4      m->locked = 0;
 5      struct thread *t = id_to_task(pop_queue(&m->wait_queue));
 6      if (t != NULL) {
 7         t->state = RUNNABLE;
 8         add_task(t);
 9      }
10   } else ...
11}
12
13void mutex_unlock_v2(struct mutex *m)
14{
15   if (m->blocking) {
16      struct thread *t = id_to_task(pop_queue(&m->wait_queue));
17      if (t == NULL) {
18         m->locked = 0;
19      } else {
20         t->state = RUNNABLE;
21         add_task(t);
22      }
23   } else ...
24}
```

- 区别：mutex_unlock_v1 和 mutex_unlock_v2 在处理阻塞锁的释放逻辑上存在显著差异：在 mutex_unlock_v1 中，当互斥锁 m 是阻塞类型时，它首先将 m->locked 设置为 0，表示锁被释放，然后从等待队列 m->wait_queue 中弹出一个线程并唤醒（如果存在），这意味着锁状态在检查等待队列之前就被修改；而 mutex_unlock_v2 则先检查等待队列是否有线程，若没有线程才将 m->locked 设置为 0，若有线程则只唤醒线程而不立即修改锁状态，这种方式推迟了锁状态的改变，直到确认没有等待者为止。因此，v1 的逻辑是先释放锁再处理等待线程，而 v2 的逻辑是先处理等待线程再决定是否释放锁。
- 潜在问题：在 mutex_unlock_v1 中，由于 m->locked 在唤醒等待线程之前被置为 0，如果此时另一个线程在唤醒完成前尝试 mutex_lock，它可能认为锁已释放并成功获取锁，而实际上等待队列中的线程尚未完全唤醒并重新竞争锁，这可能导致多个线程同时持有锁，破坏互斥性，引发数据竞争或不一致；相反，mutex_unlock_v2 在有等待线程时不立即将 m->locked 置为 0，而是先唤醒线程，依赖 mutex_lock 的实现来确保被唤醒的线程重新竞争锁，这降低了锁被错误获取的风险，但如果 mutex_lock 未正确处理 m->locked（例如未检查锁状态或未重新加入等待队列），可能导致被唤醒的线程无法及时获取锁，造成死锁或延迟。此外，v2 在没有等待线程时才释放锁，若调度器延迟，可能延长锁的持有时间，影响性能。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   > 无
   >
2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > 无
   >
3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。
4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。